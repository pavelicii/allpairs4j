/*
 * Copyright 2022 Pavel Nazimok - @pavelicii
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.github.pavelicii.allpairs4j;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

/**
 * Main class containing AllPairs algorithm and providing generated test combinations.
 * Must be instantiated using {@link AllPairsBuilder}.
 */
public final class AllPairs implements Iterable<Case> {

    private final List<Parameter> parameters;
    private final List<Predicate<ConstrainableCase>> constraints;
    /** Test combination size. */
    private final int n;
    private final boolean printEachCaseDuringGeneration;

    private final CombinationStorage combinationStorage;
    private final int maxUniqueCombinationsExpected;
    private final List<List<Item>> itemMatrix;

    private final List<Case> generatedCases;

    private AllPairs(AllPairsBuilder allPairsBuilder) {
        parameters = allPairsBuilder.parameters;
        constraints = allPairsBuilder.constraints;
        n = allPairsBuilder.n;
        printEachCaseDuringGeneration = allPairsBuilder.printEachCaseDuringGeneration;

        combinationStorage = new CombinationStorage(n);
        itemMatrix = createItemMatrix(parameters);
        maxUniqueCombinationsExpected = calculateMaxUniqueCombinations(itemMatrix, n);

        generatedCases = generateCases();
    }

    /**
     * The entry point for users.
     *
     * @see AllPairsBuilder#withParameter(Parameter)
     * @see AllPairsBuilder#withConstraint(Predicate)
     * @see AllPairsBuilder#withTestCombinationSize(int)
     */
    public static class AllPairsBuilder {

        private final List<Parameter> parameters;
        private final List<Predicate<ConstrainableCase>> constraints;
        private int n;
        private boolean printEachCaseDuringGeneration;

        public AllPairsBuilder() {
            parameters = new ArrayList<>();
            constraints = new ArrayList<>();
            n = 2;
            printEachCaseDuringGeneration = false;
        }

        /**
         * Adds one {@code Parameter} to be processed by AllPairs algorithm.
         * <ul>
         *     <li>Must provide at least two {@code Parameter}s
         *     <li>Each {@code Parameter} must have at least one value
         *     <li>Each {@code Parameter} must have no duplicate values
         *     <li>{@code Parameter} {@code name} must be unique
         * </ul>
         *
         * @param parameter {@link Parameter}
         * @return a reference to {@code AllPairsBuilder} object
         */
        public AllPairsBuilder withParameter(Parameter parameter) {
            Objects.requireNonNull(parameter, "Parameter must be non-null");
            parameters.add(parameter);
            return this;
        }

        /**
         * Adds {@code List} of {@code Parameter}s to be processed by AllPairs algorithm.
         *
         * @param parameters {@code List} of {@link Parameter}s
         * @return a reference to {@code AllPairsBuilder} object
         * @see AllPairsBuilder#withParameter(Parameter)
         */
        public AllPairsBuilder withParameters(List<Parameter> parameters) {
            Objects.requireNonNull(parameters, "Parameters must be non-null");
            this.parameters.addAll(parameters);
            return this;
        }

        /**
         * Adds one {@link Case} constraint to be processed by AllPairs algorithm.
         * Provided {@link Predicate} is tested against each {@code Case} generated by AllPairs algorithm.
         * If it evaluates to {@code true}, the {@code Case} under test won't be present in the result.
         * <p>
         * If now specified, all possible test combinations will be generated.
         * <p>
         * Constraint examples:
         * <pre>{@code
         *     // Cases with "Foo" and "Bar" pair won't be generated:
         *     c -> c.get("paramName1").equals("Foo") && c.get("paramName2").equals("Bar")
         *     // Cases with "paramName"'s value greater than 5 won't be generated:
         *     c -> c.get("paramName") > 5
         * }</pre>
         * If non-existent {@link Parameter} name is provided, it will always evaluate to {@code false}.
         *
         * @param constraint {@code Predicate} to be tested against all possible {@code Case}s
         * @return a reference to {@code AllPairsBuilder} object
         * @see ConstrainableCase
         * @see AllPairsBuilder#withParameter(Parameter)
         */
        public AllPairsBuilder withConstraint(Predicate<ConstrainableCase> constraint) {
            Objects.requireNonNull(constraint, "Constraint must be non-null");
            constraints.add(constraint);
            return this;
        }

        /**
         * Adds {@code List} of {@link Case} constraints to be processed by AllPairs algorithm.
         * <p>
         * If now specified, all possible test combinations will be generated.
         *
         * @param constraints {@code List} of {@code Predicate}s to be tested against all possible {@code Case}s
         * @return a reference to {@code AllPairsBuilder} object
         * @see AllPairsBuilder#withConstraint(Predicate)
         */
        public AllPairsBuilder withConstraints(List<Predicate<ConstrainableCase>> constraints) {
            Objects.requireNonNull(constraints, "Constraints must be non-null");
            this.constraints.addAll(constraints);
            return this;
        }

        /**
         * Specifies test combination length to be processed by AllPairs algorithm. 2 - pairwise, 3 - triplewise, etc.
         * <p>
         * If not specified, the default value 2 will be used.
         * <ul>
         *     <li>Must be greater than or equal to 2
         *     <li>Must be less than or equal to the number of {@link Parameter}s
         * </ul>
         *
         * @param n length of n-wise test combination
         * @return a reference to {@code AllPairsBuilder} object
         * @see AllPairsBuilder#withParameter(Parameter)
         */
        public AllPairsBuilder withTestCombinationSize(int n) {
            this.n = n;
            return this;
        }

        /**
         * Specifies that each {@link Case} should be printed during generation.
         * It could be useful for debug or to identify problems when generation takes too long.
         * <p>
         * If not specified, printing will be disabled.
         *
         * @return a reference to {@code AllPairsBuilder} object
         */
        public AllPairsBuilder printEachCaseDuringGeneration() {
            printEachCaseDuringGeneration = true;
            return this;
        }

        /**
         * Using provided configuration, build a new instance of {@link AllPairs} with generated test combinations.
         *
         * @return {@code AllPairs} instance
         */
        public AllPairs build() {
            validate();
            return new AllPairs(this);
        }

        private void validate() {
            if (n < 2) {
                throw new IllegalArgumentException("Minimum test combination size is 2. Provided: " + n);
            }

            if (parameters.size() < n) {
                throw new IllegalArgumentException(String.format(
                        "The number of Parameters (%d) must be greater than ot equal to the test combination size (%d)",
                        parameters.size(), n
                ));
            }

            parameters.forEach(parameter -> {
                if (parameter.isEmpty()) {
                    throw new IllegalArgumentException("Each Parameter must have at least one value. "
                            + "Provided Parameter with no values: " + parameter.getName());
                }

                if (parameter.getName() == null) {
                    throw new IllegalArgumentException("Parameter name must be non-null. Provided: " + parameter);
                }

                if (parameter.getName().equals("")) {
                    throw new IllegalArgumentException("Parameter name must not be empty. Provided: " + parameter);
                }

                if (parameter.stream().distinct().count() != parameter.size()) {
                    throw new IllegalArgumentException(
                            "Each Parameter must have no duplicate values. Provided: " + parameter
                    );
                }
            });

            final Set<String> nonUniqueParameterNamesFiller = new HashSet<>();
            final Set<String> nonUniqueParameterNames = parameters.stream()
                    .map(Parameter::getName)
                    .filter(name -> !nonUniqueParameterNamesFiller.add(name))
                    .collect(Collectors.toSet());
            if (!nonUniqueParameterNames.isEmpty()) {
                throw new IllegalArgumentException(
                        "Parameter name must be unique. Provided non-unique names: " + nonUniqueParameterNames
                );
            }
        }
    }

    public List<Parameter> getParameters() {
        return parameters;
    }

    public int getTestCombinationSize() {
        return n;
    }

    public List<Predicate<ConstrainableCase>> getConstraints() {
        return constraints;
    }

    public List<Case> getGeneratedCases() {
        return generatedCases;
    }

    @Override
    public Iterator<Case> iterator() {
        return generatedCases.iterator();
    }

    @Override
    public String toString() {
        if (generatedCases != null) {
            final AtomicInteger index = new AtomicInteger(1);
            return generatedCases.stream()
                    .map(c -> String.format("%3d: %s", index.getAndIncrement(), c.toString()))
                    .collect(Collectors.joining(System.lineSeparator()));
        } else {
            return "Cases are not generated yet";
        }
    }

    private List<Case> generateCases() {
        final List<Case> cases = new ArrayList<>();

        int caseCount = 0;
        while (true) {
            final Case nextCase = generateNextCase();
            if (nextCase == null) {
                break;
            }
            if (printEachCaseDuringGeneration) {
                System.out.printf("%3d: %s%n", ++caseCount, nextCase);
            }
            cases.add(nextCase);
        }

        return cases;
    }

    /**
     * Generates next {@code Case} using AllPairs algorithm.
     *
     * @return {@link Case} or {@code null} if all {@code Case}s are already found
     */
    private Case generateNextCase() {
        if (combinationStorage.getLength() > maxUniqueCombinationsExpected) {
            throw new RuntimeException("Actual number of combinations exceeded possible maximum");
        }

        if (combinationStorage.getLength() == maxUniqueCombinationsExpected) {
            return null; // All combinations are found
        }

        final int previousUniqueCombinationsCount = combinationStorage.getLength();
        final List<Item> chosenItems = new ArrayList<>();
        final List<Integer> itemIndexes = new ArrayList<>();
        for (int i = 0; i < itemMatrix.size(); i++) {
            chosenItems.add(null);
            itemIndexes.add(null);
        }

        int direction = 1;
        int i = 0; // Item group index

        while (i > -1 && i < itemMatrix.size()) {
            if (direction == 1) {
                updateWeightsAndReSortItemMatrix(chosenItems.subList(0, i), i);
                itemIndexes.set(i, 0);
            } else {
                itemIndexes.set(i, itemIndexes.get(i) + 1);
                if (itemIndexes.get(i) >= itemMatrix.get(i).size()) {
                    direction = -1;
                    if (i == 0) {
                        return null; // Can't find more new combinations after all values brute force
                    }
                    i += direction;
                    continue;
                }
            }

            chosenItems.set(i, itemMatrix.get(i).get(itemIndexes.get(i)));

            if (constraints == null || constraints.isEmpty() || isValidCase(chosenItems.subList(0, i + 1))) {
                direction = 1;
            } else {
                direction = 0;
            }

            i += direction;

            if (i == itemMatrix.size()) {
                combinationStorage.addSequenceCombinations(chosenItems);
                // Chosen items didn't produce new combinations
                if (combinationStorage.getLength() == previousUniqueCombinationsCount) {
                    direction = -1;
                    i += direction;
                }
            }
        }

        return new Case(chosenItems);
    }

    private void updateWeightsAndReSortItemMatrix(List<Item> chosenItems, int itemGroupIndex) {
        for (Item item : itemMatrix.get(itemGroupIndex)) {
            final Node node = combinationStorage.getNodeOrCreateNew(item);

            final List<Set<List<String>>> newItemIdCombinations = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                final List<Item> items = new ArrayList<>(chosenItems);
                items.add(item);

                final Set<List<String>> newItemIdCombination = StreamSupport
                        .stream(Itertools.combinations(items, i + 1).spliterator(), false)
                        .map(itemCombination -> itemCombination.stream()
                                .map(Item::getItemId)
                                .collect(Collectors.toList()))
                        .collect(Collectors.toSet());
                newItemIdCombination.removeAll(combinationStorage.getItemIdCombinations().get(i));

                newItemIdCombinations.add(newItemIdCombination);
            }

            final List<Integer> weights = new ArrayList<>();
            // Node that creates most new combinations is the best
            weights.add(-newItemIdCombinations.get(newItemIdCombinations.size() - 1).size());
            // Less used outbound connections are most likely to produce more combinations
            weights.add(node.getOutboundItemIdsSize());
            if (newItemIdCombinations.size() >= 2) {
                for (int i = newItemIdCombinations.size() - 2; i >= 0; i--) {
                    weights.add(newItemIdCombinations.get(i).size());
                }
            }
            weights.add(node.getCounter()); // Less used node is better
            weights.add(-node.getInboundItemIdsSize()); // Prefer node with most free inbound connections

            item.setWeights(weights);
        }

        Collections.sort(itemMatrix.get(itemGroupIndex));
    }

    private List<List<Item>> createItemMatrix(List<Parameter> parameters) {
        final List<List<Item>> matrix = new ArrayList<>();

        int i = 0;
        for (Parameter parameter : parameters) {
            matrix.add(new ArrayList<>());
            for (int j = 0; j < parameter.size(); j++) {
                matrix.get(i).add(new Item(String.format("a%dv%d", i, j), parameter.get(j), parameter.getName()));
            }
            i++;
        }

        return matrix;
    }

    private int calculateMaxUniqueCombinations(List<List<Item>> itemMatrix, int n) {
        final List<List<Item>> allPossibleCombinations = StreamSupport
                .stream(Itertools.combinations(itemMatrix, n).spliterator(), false)
                .flatMap(itemsComb -> StreamSupport.stream(Itertools.product(itemsComb).spliterator(), false))
                .filter(this::isValidCase)
                .collect(Collectors.toList());
        return allPossibleCombinations.size();
    }

    /**
     * Tests all constraints.
     *
     * @param aCase {@link Case} to test all constraints against
     * @return {@code false} if met at least one constraint, {@code true} if no constraints met
     */
    boolean isValidCase(Case aCase) {
        if (constraints.isEmpty()) {
            return true;
        }

        final ConstrainableCase constrainableCase = new ConstrainableCase(aCase);
        for (Predicate<ConstrainableCase> constraint : constraints) {
            try {
                if (constraint.test(constrainableCase)) {
                    return false;
                }
            } catch (ConstrainableCase.NoSuchParameterNameException ignored) {
                // NoSuchKeyInCaseException is used for program flow to allow Constraints to work as Predicates
                // NoSuchKeyInCaseException is optimized to cause as little performance penalty as possible
            }
        }

        return true;
    }

    private boolean isValidCase(List<Item> items) {
        return isValidCase(new Case(items));
    }
}
